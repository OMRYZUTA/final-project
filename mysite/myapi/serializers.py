from rest_framework import serializers
from .models import Position, ApplicationProcess, Countries, Contact, Stage


class PositionSerializer(serializers.HyperlinkedModelSerializer):
    id = serializers.IntegerField(read_only=True)

    class Meta:
        model = Position
        fields = '__all__'

    def validate_country_id(self, value):
        if value not in Countries.objects.values_list('id', flat=True):
            raise serializers.ValidationError(
                f'{value}  is not a valid country code')
        return value


class ContactSerializer(serializers.HyperlinkedModelSerializer):
    id = serializers.IntegerField(default=None, write_only=False)
    application_process_id = serializers.PrimaryKeyRelatedField(
        many=False, read_only=True)

    class Meta:
        model = Contact
        fields = '__all__'


class StageSerializer(serializers.HyperlinkedModelSerializer):
    id = serializers.IntegerField(read_only=True)
    application_process_id = serializers.PrimaryKeyRelatedField(
        many=False, read_only=True)

    class Meta:
        model = Stage
        fields = '__all__'
        # list_serializer_class = StageListSerializer


# class StageListSerializer(serializers.ListSerializer):
#     child = StageSerializer()

    # def update(self, instance, validated_data):
    #     # Maps for id->instance and id->data item.
    #     stage_mapping = {stage.id: stage for stage in instance}
    #     data_mapping = {item['id']: item for item in validated_data}
    #     # Perform creations and updates.
    #     ret = []
    #     for stage_id, data in data_mapping.items():
    #         stage = stage_mapping.get(stage_id, None)
    #         if stage is None:
    #             ret.append(self.child.create(data))
    #         else:
    #             ret.append(self.child.update(stage, data))

    #     # Perform deletions.
    #     for stage_id, stage in stage_mapping.items():
    #         if stage_id not in data_mapping:
    #             stage.delete()

    #     return ret


class ApplicationProcessSerializer(serializers.HyperlinkedModelSerializer):
    id = serializers.IntegerField(read_only=True)
    position = PositionSerializer()
    # contact_set ApplicationProcess field automatically generated by django (because of many-to-one)
    contact_set = ContactSerializer(many=True, read_only=False)
    stage_set = StageSerializer(many=True, read_only=False)

    class Meta:
        model = ApplicationProcess
        fields = '__all__'

    def create(self, validated_data):
        position_validated_data = validated_data.pop('position')
        position_serializer = self.fields['position']
        position = position_serializer.create(position_validated_data)
        validated_data['position'] = position

        contacts_data = validated_data.pop('contact_set')
        stages_data = validated_data.pop('stage_set')
        application_process = ApplicationProcess.objects.create(
            **validated_data)

        for contact_data in contacts_data:
            Contact.objects.create(
                application_process_id=application_process, **contact_data)

        for stage_data in stages_data:
            Stage.objects.create(
                application_process_id=application_process, **stage_data)

        return application_process

    def update(self, instance, validated_data):
        # CHANGE "position" here to match one-to-one field name
        if 'position' in validated_data:
            nested_position_validated_data = validated_data.pop('position')
            nested_position_serializer = self.fields['position']
            nested_position_instance = instance.position
            # Runs the update on whatever serializer the nested data belongs to
            nested_position_serializer.update(
                nested_position_instance, nested_position_validated_data)

        if 'contact_set' in validated_data:

            nested_contact_validated_data = validated_data.pop('contact_set')
            nested_contact_serializer = self.fields['contact_set']
            nested_contact_instance = instance.contact_set
            contacts_to_remove = {
                contact.id: contact for contact in instance.contact_set.all()}
            for contact in nested_contact_validated_data:
                contact_id = contact.get('id', None)
                if contact_id is None:
                    # new contact to created
                    instance.contact_set.create(**contact)
                elif contacts_to_remove.get(contact_id, None) is not None:
                    # update this item
                    instance_contact = contacts_to_remove.pop(contact_id)
                    Contact.objects.filter(
                        id=instance_contact.id).update(**contact)
            for contact in contacts_to_remove.values():
                contact.delete()

            # undo this delete later
            validated_data.pop('stage_set')
            for field in validated_data:
                setattr(instance, field, validated_data.get(
                    field, getattr(instance, field)))
            instance.save()

            return instance

        # if 'stage_set' in validated_data:
            # nested_stage_set_validated_data = validated_data.pop('stage_set')
            # nested_stage_set_serializer = self.fields['stage_set']
            # nested_stage_set_instance = instance.stage_set
            # Runs the update on whatever serializer the nested data belongs to

            # nested_position_serializer.update(
            #     nested_position_instance, nested_position_validated_data)
            #  for answer in validated_data.pop('answers'):
    #         ans, _created = Answer.objects.get_or_create(**answer)
    #         ans.question = instance
    #         ans.save()
    #         answer_ids_new.append(ans.id)

    #     delete_ids = set(answer_ids_pre) - set(answer_ids_new)
    #     Answer.objects.filter(id__in=delete_ids).delete()
    # for item, value in validated_data.items():
    #     setattr(instance, item, value)

            # for stage in nested_stage_set_validated_data:
            #     nested_stage_serializer.update(
            #         stage, nested_stage_validated_data)

        # Runs the original parent update(), since the nested fields were "popped" out of the data
        return super(ApplicationProcessSerializer, self).update(instance, validated_data)

    #     profile = instance.accountprofile

    #     # * User Info
    #     instance.first_name = validated_data.get(
    #         'first_name', instance.first_name)
    #     instance.last_name = validated_data.get(
    #         'last_name', instance.last_name)
    #     instance.email = validated_data.get(
    #         'email', instance.email)
    #     instance.save()

    #     # * AccountProfile Info
    #     profile.gender = profile_data.get(
    #         'gender', profile.gender)
    #     profile.phone = profile_data.get(
    #         'phone', profile.phone)
    #     profile.location = profile_data.get(
    #         'location', profile.location)
    #     profile.birth_date = profile_data.get(
    #         'birth_date', profile.birth_date)
    #     profile.biodata = profile_data.get(
    #         'biodata', profile.biodata)
    #     profile.save()

    #     return instance
